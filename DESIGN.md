After many Cabot all-nighter study sessions on the parts of both website creators, we decided to create a centralized database of study planning resources in the form of the Cabotato website. We decided to create a website because it is easily accessible from users’ computers while they are studying. In addition, a Flask-backed website allows us to integrate other languages such as SQL databases, JavaScript, CSS, and Python for the behind the scenes routing of the HTML-coded websites. When we were brainstorming website pages, our main priority was to design features that would alleviate a different need that users may have when studying at Cabot.

Users begin at the registration page, where we use HTML to structure the page. We included <input> tags to get the information we wanted from users to allow them to register. Specifically, we collected their name, username, password, and confirmation. We also used Jinja templating on this page to follow the base template we created in layout.html so that the registration page reflects the same formatting as other pages. The registration page includes a <form> element to send user data to the server to be processed. Flask, a key aspect of our website, then handles the routing and processing of these HTTP requests. For register, it was used to process submissions in SQL databases. To actually store information from users, we made a database table called users and used db.execute to insert user information into the database. As for the form methods, users access the form via a GET request and a POST request sends the form data to the server, which validates the data, hashes the password, and stores it. If the user doesn’t meet certain conditions, such as providing a matching password and confirmation password, they will be prompted to fix that. If they forget to provide a certain field, they will be prompted to provide it via theapology function which gives a “Cabotato Gone Wrong” message to the users.

As for the login page, the HTML template (login.html) includes a form that asks for two inputs, username and password. There is also a submit button that uses a POST request to send the form data to the server. From here, the route is defined in the app.py file for our code, where the page is displayed when the user clicks login in the navigation bar. This is when “login.html” is used. As for POST requests, these happen when a user submits the login form. We begin with session.clear() to remove an existing session and its data. Then, the input that users provide is validated and if a field is missing, users get a “Cabotato Gone Wrong” Error. Then, we query a SQL database via db.execute() to find the row where the username matches the submitted value. The check_password_hash() function then confirms that the password users provide matches with the stored hash. If this authentication process fails, a “Cabotato Gone Wrong” apology is sent. If the users are successful in logging in, then their id is stored in the session and they are redirected to the Cabotato home page. We learned about the werkzeug.security library which securely stores the passwords in a database as hashes. Additionally, if this process is successful, any area in our app.py file that has “@login_requried” is only accessible to users who successfully login. We also used the layout template to make this by having a {% if session["user_id"] %} block and within this, all the pages that are only accessible via login are shown, and our else block has the constant pages (register and login).

The home page is only available once the user has logged in. Most of the code for this is located in the home.html file, which has a description of the website and a cute photo at the top. We included a Bootstrap-backed carousel at the bottom where the user can click through five different photos of Cabot library that showcase its history and common student usage, with titles and captions accompanying each photo. The sizing of all of these visual graphics and similar photos across the website are set to update based on the size of the user’s device.

For our study leaderboard, the leaderboard.html extends the bse layout in layout.html via Jinja. There is a submission form that allows users to log their study progress. <input type="text" name="name"> is used to get the users name and similar structures are used to get the number of assignments completed and time spent. Data is submitted via a POST request and the leaderboard table is updated with top performers. We then use SQL to order the top 10 entries on the leaderboard based on the number of assignments completed. We also display how much time users are spending on these assignments. We do this with leaderboard = db.execute("SELECT name, assignments, time FROM progress ORDER BY assignments DESC, time DESC LIMIT 10"). The ORDER BY function here is very crucial for displaying the leaders in descending order. We have created a progress table with SQL that stores this data with an id for each entry, the name of the participants, assignments, and time.

As for the study page, we once again use Jinja templating to have our base layout from layout.html. We also use Bootstrap for a CSS framework to style our buttons and headers with classes like container, navbar-brand, btn btn-primary, and mb-5. To integrate the Pomdoro Timer, a timer that runs for the 25 minutes of work, then 5 minutes for a break. We used JavaScript to do this by making an isWorking variable that tracks if the current session is a work session or a break. The timeLeft variable tracks how much time is left. The timer variable stores the interval ID that is returned by setInterval. We created a function called update timerDisplay to convert timeLeft into minutes: seconds so that it appears in a normal way to users (instead of showing the entire 30 minutes in seconds). Then we have the startTimer function, which resets and starts a “setInterval” timer. By using an if statement based on if the time left is 0, it will clear the timer, reset the session, and re-enable the start button by doing startButton.disabled = false. We also have a takeBreak function which sets isWorking to false and resets timeLeft to 5 minutes. We also have a restartTimer function which resets timeLeft to 25 minutes and a stopTimer function which stops the counting but doesn’t reset the session (done using clearInterval). In addition to using JavaScript for a timer, we integrated Spotify on this page so users can listen directly from Spotify without leaving the Cabotato Website. We did this using Spotify’s embed code in the html file for our study page.

The room booking page involves two primary components: reserving rooms and filtering the rooms. As for reserving rooms, roombook.html extends the base layout file (layout.html) just like our other template pages. It then displays 6 different rooms in the Cabot library, with images and descriptions accurately reflecting the current Cabot Library page done by Harvard on the Find a Space Website they have. Once a user clicks a room, they have a booking form with a hidden input (room_id) that stores the id of the room being booked, a date input, start time, and end time. By using a series of loops, including {% for hour in range(0, 24) % and  {% for minute in [0, 15, 30, 45] %}, we made it so that the times only showed up for every 15 minutes because it’s not practical to book a room for a very exact time like say 3:07 P.M. This is also how most room bookings are done. As for JavaScript implementation, we used JavaScript to retrieve the current date. This allowed us to make it so that users couldn’t book rooms in the past, as this wouldn’t be practical. The form submission uses the submit event listener and we then integrated teh Fetch API to send the data from the form to the server. Depending on the server response, if the booking is successful, users would get a success message or an error message. If the booking was successful, the form is reset. On the server side, Python handles the booking requests. In app.py, we made the check_room_availability function to keep users from double-booking. It works by querying hte booking table to find overlapping reservations. If the room is available, the reservation details (user ID, room ID, date, start time, end time) are stored in the bookings table using an INSERT SQL statement. As for filtering rooms, this is included in the main block of the page and is a form set to submit a GET request to the /filter endpoint. In the filter form, there is a date picker, which uses a <input type="date" name="filter_date"> field to get the date where users are interested in reserving a room. Then there are <select> elements containing start times and end times for users to pick from. Using loops to find 15 minute increments, we turned the times from the default 24 hours to 12 hour format and only showed every 15 minutes. Once the user submits the filter form, a GET request is sent and the server processes the selected date. The server queries the database for rooms that don't overlap with the submitted date and time by checking for room reservations in the database that overlap. If there are existing reservations during the selected start_time or end_tiem, it’s considered unavailable. The filter rooms route in the python file also goes through the rooms list we created in the python file to only include those that are not in booked_room_ids which is a variable that stores the room IDs that have overlapped bookings (found from querying through the database). end_time <= filter_start_time is used to exclude bookings that end before the requested start time and start_time >= filter_end_time is used to exclude bookings that start after the requested end time. We use >= and <= so that bookings that overlap in anyways are excluded, not just identical bookings. The variable available_rooms iterates overall all the rooms in the rooms list and filters out the ones with an id in booked_room_ids and then the roombook.html template is returned with the avialable_rooms list passed to it so that only available rooms are shown instead of the standard list of all rooms.

For the “Food Spots” page, we used HTML to code the website’s design and Jinja to cycle through each of the food spots so that they can be displayed as a card on the screen. We chose to integrate a SQL database because it could store multiple information categories under one restaurant entry including the name, address, and offered food options. The Python functions connected to the webpage were split into two separate functions so that they could be easily referenced for each of the different functions that the user can complete on the page. The food_spots function retrieves all restaurant data from the restaurants table and renders the foodspots.html page, acting as a central entry point for viewing available options when the user first accesses the page from another page on the website. The search function handles user queries by searching the restaurants SQL table for any restaurant names or food options that match the user’s query in the search box, creating a list of only the matching restaurants that the HTML code for the page then iterates through to show the user only the relevant results. If the HTML page is given an empty list of matching restaurants (indicating that there are no matches), then the HTML website is programmed to display a message that none are found. Separating these tasks into three distinct functions keeps the code modular and easier to maintain, with each function focused on a specific responsibility. Additionally, we imported the Leaflet JavaScript library to include an interactive map at the bottom of the Food Spots page, where the user can click through different markers of the featured restaurants to gauge their location and also learn their names. By binding the pop-up of the restaurant name to each marker, we used Leaflet’s internal programming to open the automatically open the pop-up once the user clicks on it.

The “Friend Tracker” page has an HTML file for the website, the “friend_tracker” function for routing the user’s information, and the “friends” in the SQL database to dynamically manage and update study location data logs of where website users are studying. Depending on the HTTP method, the application processes user inputs differently. When a POST request is made (indicating a form submission), the code collects information entered by the user, such as the study location, level of focus, and study duration. Using these inputs, Python calculates the study session’s end time and associates it with the user’s unique session ID and name retrieved from the database. It then updates the SQL database by removing any previous records for the user and inserting the new data, ensuring that only the most recent study session details are stored. In contrast, when a GET request is made (indicating a page load or refresh), the code retrieves and processes data from the database to display current study information. For each study location, the SQL query filters records to include only those friends whose study sessions are still active based on the calculated end time. Any expired records are automatically deleted from the database, ensuring that only valid and current information is presented. The resulting data, including the names and “locked-in” focus levels of friends, is then passed to the HTML template for rendering.

Lastly, the logout function in our python file clears the session using session.clear and then a message is flashed telling the user they have been logged out. From here the function redirects the user to the login page by returning redirect(“/”) to send them back to a main page after logging out. As for our sources, we have listed any specific links and we have also used Claude, ChatGPT, and the duck as helpers to assist  with syntax challenges or exploring new features to elevate our website, like learning how to incrmeent time by 15 minutes in our room booking, for example. (as opposed to having every possible time listed)
